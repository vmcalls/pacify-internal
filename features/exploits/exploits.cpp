#include <includes.h>

void features::exploits::fly::run( SDK::ACharacter* character )
{
    if ( !character || !character->CharacterMovement ) return;

    auto capsule = character->CapsuleComponent;
    auto mesh = character->Mesh;

    if ( !variables::misc::fly_ex )
    {
        if ( character->CharacterMovement->MovementMode == SDK::EMovementMode::MOVE_Flying )
        {
            character->CharacterMovement->MovementMode = SDK::EMovementMode::MOVE_Walking;
            character->CharacterMovement->GravityScale = 1.f;
        }

        if ( mesh && capsule )
        {
            capsule->SetCollisionEnabled( SDK::ECollisionEnabled::QueryAndPhysics );
            capsule->SetCollisionResponseToAllChannels( SDK::ECollisionResponse::ECR_Block );

            mesh->SetCollisionEnabled( SDK::ECollisionEnabled::QueryOnly );
            mesh->SetCollisionResponseToAllChannels( SDK::ECollisionResponse::ECR_Ignore );
        }

        character->SetActorEnableCollision( true );
        return;
    }    

    if ( capsule && mesh )
    {
        capsule->SetCollisionEnabled( SDK::ECollisionEnabled::NoCollision );
        capsule->SetCollisionResponseToAllChannels( SDK::ECollisionResponse::ECR_Ignore );

        mesh->SetCollisionEnabled( SDK::ECollisionEnabled::NoCollision );
        mesh->SetCollisionResponseToAllChannels( SDK::ECollisionResponse::ECR_Ignore );
    }

    character->SetActorEnableCollision( false );

    character->CharacterMovement->bCheatFlying = true;
    character->CharacterMovement->SetMovementMode( SDK::EMovementMode::MOVE_Flying, 0 );

    character->CharacterMovement->MaxFlySpeed = 1000.0f;
    character->CharacterMovement->MaxFlySpeed = 1000.0f;
    character->CharacterMovement->MaxAcceleration = 1000.0f;

    if ( GetAsyncKeyState( VK_SPACE ) & 0x8000 )
    {
        SDK::FVector currentVelocity = character->CharacterMovement->Velocity;
        character->CharacterMovement->Velocity = SDK::FVector( currentVelocity.X, currentVelocity.Y, 1000.0f );
    }
    else if ( GetAsyncKeyState( VK_LSHIFT ) & 0x8000 )
    {
        SDK::FVector currentVelocity = character->CharacterMovement->Velocity;
        character->CharacterMovement->Velocity = SDK::FVector( currentVelocity.X, currentVelocity.Y, -1000.0f );
    }
    else
    {
        SDK::FVector currentVelocity = character->CharacterMovement->Velocity;
        character->CharacterMovement->Velocity = SDK::FVector( currentVelocity.X, currentVelocity.Y, 0.0f );
    }
}

void features::exploits::speed::run( SDK::ACharacter* character )
{
    if ( !character || !character->CharacterMovement ) return;

    auto move = character->CharacterMovement;

    if ( !variables::misc::speed_ex )
    {
        move->MaxWalkSpeed = 600.f;
        move->MaxFlySpeed = 600.f;
        return;
    }

    move->MaxWalkSpeed = 2400.f;
    move->MaxFlySpeed = 2400.f;
}

inline void set_freeze( SDK::AActor* actor, bool freeze )
{
    if ( !actor ) return;

    auto character = reinterpret_cast< SDK::ACharacter* >( actor );
    if ( character && character->CharacterMovement )
    {
        if ( freeze )
        {
            character->CharacterMovement->DisableMovement( );
            character->CharacterMovement->Deactivate( );
            character->CharacterMovement->Velocity = { 0.f, 0.f, 0.f };
        }
        else
        {
            character->CharacterMovement->SetMovementMode( SDK::EMovementMode::MOVE_Walking, 0 );
            character->CharacterMovement->Activate( true );
        }
    }

    actor->SetActorTickEnabled( !freeze );
}

void features::exploits::freeze_ghost::run( SDK::UWorld* world )
{
    if ( !world ) return;

    for ( int li = 0; li < world->Levels.Num( ); ++li )
    {
        auto lvl = world->Levels[ li ];
        if ( !lvl ) continue;

        for ( int ai = 0; ai < lvl->Actors.Num( ); ++ai )
        {
            auto a = lvl->Actors[ ai ];
            if ( !a ) continue;

            std::string nm = a->GetName( );
            if ( nm.find( "Scary_MP" ) != std::string::npos && nm.find( "HungryGhost" ) != std::string::npos )
            {
                set_freeze( a, variables::misc::freeze_ghost );
            }

            /*if ( nm.find( "Scary_MP" ) != std::string::npos )
            {
                set_freeze( a, variables::misc::freeze_ghost );
            }*/
        }
    }
}

void features::exploits::fullbright::run( SDK::UWorld* world )
{
    if ( !world ) return;

    for ( int li = 0; li < world->Levels.Num( ); ++li )
    {
        auto level = world->Levels[ li ];
        if ( !level ) continue;

        for ( int ai = 0; ai < level->Actors.Num( ); ++ai )
        {
            auto actor = level->Actors[ ai ];
            if ( !actor ) continue;

            if ( actor->IsA( SDK::AExponentialHeightFog::StaticClass( ) ) )
            {
                auto fog_actor = reinterpret_cast< SDK::AExponentialHeightFog* >( actor );

                SDK::UExponentialHeightFogComponent* fog = fog_actor->Component;
                if ( !fog ) continue;

                fog->SetFogDensity( 0.0f );
                fog->SetFogMaxOpacity( 0.0f );
                fog->SetStartDistance( 1'000'000.0f );
                fog->SetFogCutoffDistance( 0.0f );
                fog->SetVolumetricFog( false );
                fog->SetFogInscatteringColor( { 1.f, 1.f, 1.f, 1.f } );

                fog->SetDirectionalInscatteringStartDistance( 1'000'000.0f );
            }
        }
    }
}